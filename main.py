from re import split
config=[0,True, ''] #Настройки по умолчанию
def word_search(text: str, word: str,num_of_Err:int=0, Ignore_case:bool=True, replacement:str ='')->list:#text- текст в котором ищем; word- слово которое ищем; num_of_Err- количество допустимых ошибок; Ignore_case- игнорироватьгнорировать ли регистр (если True то игнорировать); replacement- если его указать, то все найденные слова будут заменены на replacement
    counter=0 #счётчик правильности слова
    if len(text)==0:
        text=' '
    text=text.replace('(',' (')#Исправляем ошибку при которой человек не ставит пробел до или полсе скобок, и те прилипают к внешнему слову
    text=text.replace(')',') ')
    if Ignore_case:#Игнорировать ли регистр
        word=word.upper()
    sub_couter1=0#Вспомогательный счётчик правильности
    sub_couter2=0#Вспомогательный счётчик правильности
    result=[]#Список предложений с искомым словом
    sub_result=''#Вспомогательный str для result
    if text[len(text)-1]!='.': #Добовляет в конец точку, если её нет для работы split
        text+='.'               
    len_of_word=len(word)    #Делит текст на предложения
    offers=split(r'[.?!]+', text) #Делит текст на преложения. re надо для того, чтобы не писать 3 split
    for i in offers: #Идёт по всем предложениям
        words=i.split() #Делит предложение на слова
        for u in words:#Идёт по словам в предложениии
            if u[len(u)-1]==',' or u[len(u)-1]=='.' : #Уберает в cловах запятую и точку
                u=u[0:len(u)-1]
            uo=u #вспомогательная переменная копирующая текущие слово
            u=u.replace('(',' ')#Убераем скобки для коректного поска слова
            u=u.replace(')',' ')#Убераем скобки для коректного поска слова
            u=u.replace(' ','')#Убераем пробелы для коректного поска слова
            if Ignore_case:#Игнорировать ли регистр
                u=u.upper() #Если мы игрорируем регистр то все буквы в слове становятся заглавными
            if (len(u) - len_of_word)**2<=0: #Данное условие сравнивает длину искомого слова с длиной конкретного слова, это надо будет для ввода с ошибкой (если пользователь забыл пару букв)
                for o in range(len(u)): 
                    if word[o] == u[o]: #Узнаёт количество одинаковых букв
                        counter+=1
                if counter>=len_of_word- num_of_Err: #Это условие указывает подходит ли слово, учитывая количество букв в искомом слове, количесво совпадений и допустимое количесво ошибок
                    #print(u)
                    if replacement=='': #Смотрит есть ли замена
                        result.append(i)
                    elif replacement!='': #замена слова
                        for h in words: #Идёт по словам, для добовления их в result и замены искомого слова
                            if h!=uo and h!=uo+',' and h!=uo+'.': #Проверяет не заменялимое ли это слово 
                                #print(h, uo)
                                sub_result+=h+' ' #Создаёт предложенииe из слов
                            elif h==uo or h==uo+',' or h==uo+'.':
                                sub_result+=replacement+' '  #Создаёт предложенииe из слов
                        result.append(sub_result[0:len(sub_result)-1]+'.')#Добовляет предложенииe в result и точку в конец
                counter=0 #Обнуление счётчика
                sub_result='' #Обнуление вспомогательного str
            elif (len(u) - len_of_word)**2<=num_of_Err**2: #Это условие проходит если длинна слова не совподает на количесво ошибок или меньше
                difference=(len(u) - len_of_word)**2 #делает difference положительным
                difference=int(difference**0.5) #делает difference положительным
                u1=u[0:len(u)-difference] #Создаёт вспомогательную переменную содержащию текущиеслово урезанное до размеров искомого слова
                u2=u[difference:len(u)] #Создаёт вспомогательную переменную содержащию текущиеслово урезанное до размеров искомого слова
                for o in range(len(u)-difference): 
                    if word[o] == u1[o]:
                        sub_couter1+=1
                    if word[o] == u2[o]:
                        sub_couter2+=1
                if sub_couter2>=sub_couter1:#Поиск наибольшего резулятата и приравнивание его к основному счётчику
                    counter=sub_couter2
                elif sub_couter1>sub_couter2:
                    counter=sub_couter1
                if counter-abs(difference)>=len_of_word- num_of_Err:
                    if replacement=='':
                        #print(u)
                        result.append(i)
                    elif replacement!='': #замена слова
                        for h in words: #идёт по словам в предложении и добовляет их в результат
                            if h!=uo  and h!=uo+',' and h!=uo+'.':#Проверяет не заменялимое ли это слово 
                                sub_result+=h+' ' #Вы это читаете?
                            elif h==uo or h==uo+',' or h==uo+'.': # Если это искомое слово, то вместо него вставляется замена
                                sub_result+=replacement+' ' 
                        result.append(sub_result[0:len(sub_result)-1]+'.')#Добовляет в результат предложение без последнего символа (он всегда пробел) и добовляет в конец точку (ранее мы её удалили для коректного поиска слова)
                elif counter-abs(difference)<len_of_word- num_of_Err: #Очень хитрый алгоритм, который находит cлово с отсутвующей буквой посреди слова
                    counter=0 #Обнуление счётчика 
                    # print(u)
                    for j in range(1,len(u)+1): #Идёт по длине слова пропуская 1 букву
                        # print('u')
                        for j2 in range(1,num_of_Err+1): #Идёт от 1 до количесва ошибок
                            u3=u[0:j]+' '*j2+u[j:len(u)] # Добовляет пробелы посреди слова, для того, чтобы прошла проверка если пользователь забыл символ посреди слова ("Солнце", "Сонце")
                            rp=max(len(u3),len_of_word)
                            ml=min(len_of_word, len(u3))# вычисляет минимальное слово, чтобы не выйти за границы
                            for o in range(ml): #идёт от 0 до длины минимального слова
                                if word[o] == u3[o]:#сравнивает буквы в текущем слове и искомом
                                    counter+=1
                            if counter>=rp-num_of_Err:#если это то самое слова то выходим из цыкла
                                break
                            else:
                                counter=0 #Если это слово не подходим то обнуляем счётчик
                        if counter>=rp- num_of_Err:#если это то самое слова то выходим из цыкла
                            break
                    if counter>=rp- num_of_Err:#если это то записываем предложение в котором оно находится
                        if replacement=='':
                            # print(word, u,u3, counter,num_of_Err,len_of_word)
                            result.append(i)
                        elif replacement!='': #замена слова
                            for h in words: 
                                if h!=uo  and h!=uo+',' and h!=uo+'.':#Проверяет не заменялимое ли это слово 
                                    sub_result+=h+' '
                                elif h==uo or h==uo+',' or h==uo+'.': 
                                    sub_result+=replacement+' ' 
                            result.append(sub_result[0:len(sub_result)-1]+'.')
                counter=0 #Обнуление счётчика
                sub_couter1=0 #Обнуление вспомогательного счётчика
                sub_couter2=0 #Обнуление вспомогательного счётчика
    final_result="Всего найдено "+str(len(result))+' совпадений:\n'#Создаю переменную где будет храниться отформатированный вывод 
    for i in range(len(result)):#Форматирование вывода
        result[i]=result[i].replace('  ',' ')#Убераем двойные пробелы
        while result[i][0]=='\n' or result[i][0]==' ' :#Если в начале Enter или пробел то мы его убераем
            result[i]=result[i][1:]
        final_result+=str(i+1)+'. '+result[i]+'\n'
    
    return final_result #Возврат списка предложений с искомым словом
tex='''Как принято считать, реплицированные с зарубежных источников, современные исследования представляют собой не что иное, как квинтэссенцию победы маркетинга над разумом и должны быть обнародованы. Безусловно, сложившаяся структура организации однозначно фиксирует необходимость переосмысления внешнеэкономических политик. Принимая во внимание показатели успешности, перспективное планирование в значительной степени обусловливает важность экономической целесообразности принимаемых решений. Есть над чем задуматься: явные признаки победы институционализации являются только методом политического участия и объявлены нарушающими общечеловеческие нормы этики и морали.

Приятно, граждане, наблюдать, как независимые государства являются только методом политического участия и заблокированы в рамках своих собственных рациональных ограничений. Прежде всего, существующая теория способствует повышению качества распределения внутренних резервов и ресурсов.

Не следует, однако, забывать, что базовый вектор развития говорит о возможностях благоприятных перспектив. В частности, сплочённость команды профессионалов выявляет срочную потребность экономической целесообразности принимаемых решений.

С другой стороны, разбавленное изрядной долей эмпатии, рациональное мышление требует определения и уточнения переосмысления внешнеэкономических политик. Но независимые государства в равной степени предоставлены сами себе. Как уже неоднократно упомянуто, интерактивные прототипы призывают нас к новым свершениям, которые, в свою очередь, должны быть объективно рассмотрены соответствующими инстанциями. В рамках спецификации современных стандартов, предприниматели в сети интернет являются только методом политического участия и ассоциативно распределены по отраслям.

А также независимые государства формируют глобальную экономическую сеть и при этом — представлены в исключительно положительном свете. Противоположная точка зрения подразумевает, что элементы политического процесса, превозмогая сложившуюся непростую экономическую ситуацию, превращены в посмешище, хотя само их существование приносит несомненную пользу обществу.

В своём стремлении улучшить пользовательский опыт мы упускаем, что явные признаки победы институционализации призывают нас к новым свершениям, которые, в свою очередь, должны быть указаны как претенденты на роль ключевых факторов. А ещё сделанные на базе интернет-аналитики выводы объединены в целые кластеры себе подобных. Современные технологии достигли такого уровня, что сложившаяся структура организации играет определяющее значение для соответствующих условий активизации.

Наше дело не так однозначно, как может показаться: глубокий уровень погружения является качественно новой ступенью существующих финансовых и административных условий. Являясь всего лишь частью общей картины, независимые государства в равной степени предоставлены сами себе. Значимость этих проблем настолько очевидна, что разбавленное изрядной долей эмпатии, рациональное мышление прекрасно подходит для реализации как самодостаточных, так и внешне зависимых концептуальных решений.

Мы вынуждены отталкиваться от того, что социально-экономическое развитие однозначно определяет каждого участника как способного принимать собственные решения касаемо глубокомысленных рассуждений. Безусловно, понимание сути ресурсосберегающих технологий является качественно новой ступенью приоретизации разума над эмоциями. Задача организации, в особенности же семантический разбор внешних противодействий играет определяющее значение для благоприятных перспектив. Принимая во внимание показатели успешности, высокотехнологичная концепция общественного уклада требует определения и уточнения форм воздействия. Имеется спорная точка зрения, гласящая примерно следующее: действия представителей оппозиции, инициированные исключительно синтетически, своевременно верифицированы. Господа, понимание сути ресурсосберегающих технологий способствует повышению качества системы обучения кадров, соответствующей насущным потребностям.

В своём стремлении повысить качество жизни, они забывают, что дальнейшее развитие различных форм деятельности предоставляет широкие возможности для своевременного выполнения сверхзадачи. Предварительные выводы неутешительны: выбранный нами инновационный путь создаёт необходимость включения в производственный план целого ряда внеочередных мероприятий с учётом комплекса стандартных подходов. Для современного мира глубокий уровень погружения создаёт необходимость включения в производственный план целого ряда внеочередных мероприятий с учётом комплекса благоприятных перспектив.

Каждый из нас понимает очевидную вещь: постоянное информационно-пропагандистское обеспечение нашей деятельности позволяет оценить значение существующих финансовых и административных условий. Но интерактивные прототипы формируют глобальную экономическую сеть и при этом — подвергнуты целой серии независимых исследований. Ясность нашей позиции очевидна: консультация с широким активом создаёт необходимость включения в производственный план целого ряда внеочередных мероприятий с учётом комплекса благоприятных перспектив. Разнообразный и богатый опыт говорит нам, что сложившаяся структура организации предоставляет широкие возможности для первоочередных требований. Высокий уровень вовлечения представителей целевой аудитории является четким доказательством простого факта: разбавленное изрядной долей эмпатии, рациональное мышление создаёт необходимость включения в производственный план целого ряда внеочередных мероприятий с учётом комплекса стандартных подходов. Как принято считать, стремящиеся вытеснить традиционное производство, нанотехнологии формируют глобальную экономическую сеть и при этом — своевременно верифицированы.

И нет сомнений, что ключевые особенности структуры проекта, вне зависимости от их уровня, должны быть указаны как претенденты на роль ключевых факторов. Сложно сказать, почему активно развивающиеся страны третьего мира представляют собой не что иное, как квинтэссенцию победы маркетинга над разумом и должны быть обнародованы. Не следует, однако, забывать, что граница обучения кадров требует от нас анализа новых предложений.

Приятно, граждане, наблюдать, как активно развивающиеся страны третьего мира, превозмогая сложившуюся непростую экономическую ситуацию, функционально разнесены на независимые элементы. Высокий уровень вовлечения представителей целевой аудитории является четким доказательством простого факта: высокое качество позиционных исследований, в своём классическом представлении, допускает внедрение прогресса профессионального сообщества. В рамках спецификации современных стандартов, базовые сценарии поведения пользователей превращены в посмешище, хотя само их существование приносит несомненную пользу обществу. Ясность нашей позиции очевидна: укрепление и развитие внутренней структуры способствует повышению качества позиций, занимаемых участниками в отношении поставленных задач.

В своём стремлении повысить качество жизни, они забывают, что перспективное планирование требует определения и уточнения поэтапного и последовательного развития общества. В своём стремлении улучшить пользовательский опыт мы упускаем, что представители современных социальных резервов рассмотрены исключительно в разрезе маркетинговых и финансовых предпосылок! В рамках спецификации современных стандартов, диаграммы связей являются только методом политического участия и в равной степени предоставлены сами себе. Повседневная практика показывает, что высокое качество позиционных исследований требует от нас анализа новых принципов формирования материально-технической и кадровой базы. Современные технологии достигли такого уровня, что повышение уровня гражданского сознания создаёт предпосылки для поэтапного и последовательного развития общества. В целом, конечно, социально-экономическое развитие напрямую зависит от первоочередных требований.

Есть над чем задуматься: сторонники тоталитаризма в науке набирают популярность среди определенных слоев населения, а значит, должны быть функционально разнесены на независимые элементы. Мы вынуждены отталкиваться от того, что социально-экономическое развитие способствует повышению качества первоочередных требований. Учитывая ключевые сценарии поведения, семантический разбор внешних противодействий играет важную роль в формировании направлений прогрессивного развития. Разнообразный и богатый опыт говорит нам, что базовый вектор развития является качественно новой ступенью существующих финансовых и административных условий.

Мы вынуждены отталкиваться от того, что разбавленное изрядной долей эмпатии, рациональное мышление способствует повышению качества дальнейших направлений развития. Имеется спорная точка зрения, гласящая примерно следующее: диаграммы связей набирают популярность среди определенных слоев населения, а значит, должны быть заблокированы в рамках своих собственных рациональных ограничений. Разнообразный и богатый опыт говорит нам, что реализация намеченных плановых заданий требует анализа экспериментов, поражающих по своей масштабности и грандиозности.'''
# tex='I have a мат  sister, her name is Marinad. Das мт is good! Ладно. Расцветали, ат яблони и груши. Попплыли т туманны над рекой?'
# a=''
# num=0
# if True:
#     while a!='/start':
#         a=input()
#     print('Выберите действие: Настройки; Начать поиск')
#     while a!='Настройки' and a!='Начать поиск':
#         a=input()
#     if a=='Настройки':
#         num=input('Введите допустимое количесво ошибок:')
#         while not num.isdigit():
#             print('Введите число')
#             num=input('Введите допустимое количесво ошибок:')
#         config[0]=num
#         a=input('Учитывать ли регистр?(Да, Нет)')
#         while a.upper()!='ДА' and a.upper()!='НЕТ':
#             print(a.upper())
#             print("Не верный ввод")
#             a=input('Учитывать ли регистр?(Да, Нет)')
#         if a=='Да':
#             config[1]=False
#         else:
#             config[1]=True
#         a=input('Заменить найденные слова?(Да, Нет)')
#         while a.upper()!='ДА' and a.upper!='НЕТ':
#             print("Не верный ввод")
#             a=input('Заменить найденные слова?(Да, Нет)')
#         if a=='Да':
#             config[2]=str(input("На что заменить найденные слова?"))
    
#     tex=str(input("Введите текст в котором надо искать: "))
#     word=str(input("Введите искомое слово: "))
print(word_search(tex,'—',config[0],config[1],config[2]))
